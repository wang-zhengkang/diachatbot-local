"""Dialog agent interface and classes."""
from abc import ABC, abstractmethod
from convlab2.nlu import NLU
from convlab2.dst import DST
from convlab2.policy import Policy
from convlab2.nlg import NLG
from copy import deepcopy
from convlab2.util.diachat.status import DiachatSatus


class Agent(ABC):
    """Interface for dialog agent classes."""
    @abstractmethod
    def __init__(self, name: str):
        self.name = name

    @abstractmethod
    def response(self, observation):
        """Generate agent response given user input.

        The data type of input and response can be either str or list of tuples, condition on the form of agent.

        Example:
            If the agent is a pipeline agent with NLU, DST and Policy, then type(input) == str and
            type(response) == list of tuples.
        Args:
            observation (str or list of tuples):
                The input to the agent.
        Returns:
            response (str or list of tuples):
                The response generated by the agent.
        """
        pass

    @abstractmethod
    def init_session(self, **kwargs):
        """Reset the class variables to prepare for a new session."""
        pass


class DiachatAgent(Agent):
    """Pipeline dialog agent base class, including NLU, DST, Policy and NLG.

    The combination modes of pipeline agent modules are flexible. The only thing you have to make sure is that
    the API of agents are matched.

    Example:
        If agent A is (nlu, tracker, policy), then the agent B should be like (tracker, policy, nlg) to ensure API
        matching.
    The valid module combinations are as follows:
           =====   =====    ======  ===     ==      ===
            NLU     DST     Policy  NLG     In      Out
           =====   =====    ======  ===     ==      ===
            \+      \+        \+    \+      nl      nl
             o      \+        \+    \+      da      nl
             o      \+        \+     o      da      da
            \+      \+        \+     o      nl      da
             o       o        \+     o      da      da
           =====   =====    ======  ===     ==      ===
    """

    def __init__(self, nlu: NLU, dst: DST, policy: Policy, nlg: NLG, name: str = 'Doctor'):
        """The constructor of PipelineAgent class.

        Here are some special combination cases:

            1. If you use word-level DST (such as Neural Belief Tracker), you should set the nlu_model paramater \
             to None. The agent will combine the modules automitically.

            2. If you want to aggregate DST and Policy as a single module, set tracker to None.

        Args:
            nlu (NLU):
                The natural langauge understanding module of agent.

            dst (DST):
                The dialog state tracker of agent.

            policy (Policy):
                The dialog policy module of agent.

            nlg (NLG):
                The natural langauge generator module of agent.
        """
        super(DiachatAgent, self).__init__(name=name)
        assert self.name in ['User', 'Doctor']
        self.opponent_name = 'User' if self.name is 'Doctor' else 'Doctor'
        self.nlu = nlu
        self.dst = dst
        self.policy = policy
        self.nlg = nlg
        self.init_session()
        self.history = []
        self.status_list = []

    def state_replace(self, agent_state):
        """
        this interface is reserved to replace all interal states of agent
        the code snippet example below is for the scenario when the agent state only depends on self.history and self.dst.state
        """
        self.history = deepcopy(agent_state['history'])
        self.dst.state = deepcopy(agent_state['dst_state'])

    def state_return(self):
        """
        this interface is reserved to return all interal states of agent
        the code snippet example below is for the scenario when the agent state only depends on self.history and self.dst.state
        """
        agent_state = {}
        agent_state['history'] = deepcopy(self.history)
        agent_state['dst_state'] = deepcopy(self.dst.state)

        return agent_state

    """
    observation是agent接收到的输入语句，输出要做出响应的语句。
         如果agent是模拟的用户，那么observation是对话系统的输出
         如果agent是对话系统，那么observation是用户的语句
         处理逻辑：
            （1）nlu模块根据observation预测input action，就是理解接收到语句的意图和槽值，还要结合之前的对话历史
            （2）dst根据input action，更新状态，实现状态跟踪， 并且，dst记录这个（对方的）input action
            （3）policy根据状态预测将要采取的行为，即output_action，并且，dst记录这个（自己的）output action
            （4）nlg根据output_action生成语句model_response，做出响应
    """
    def response(self, observation):
        """Generate agent response using the agent modules."""
        status = DiachatSatus()
        
        #收到用户语句，加入history
        self.dst.state['history'].append([self.opponent_name, observation]) # [['sys', sys_utt], ['user', user_utt],...]
        status.input_utterance = observation
        #对用户语句进行NLU
        self.input_action = self.nlu.predict(observation, context=[x[1] for x in self.history[:-1]])
        self.input_action = deepcopy(self.input_action) # get rid of reference problem
        status.input_action = self.input_action
        #更新系统状态，在update函数里会把用户的action写入state['user_action']
        state = self.dst.update(self.input_action)
        state = deepcopy(state) # get rid of reference problem
        self.current_state = state
        #预测出系统的下一步行为，在predict函数里会把系统的action写入state['system_action']
        output_action,polciy_action = self.policy.predict(state)
        status.policy_action = polciy_action
        status.output_action = output_action
        self.output_action = deepcopy(output_action) # get rid of reference problem
        self.dst.update_by_sysda()#根据system action更新belief state，system action在policy部分已传入        
        #根据预测的行为生成自然语言的回答
        model_response = self.nlg.generate(self.output_action)
        status.output_utterance = model_response
        #把系统的回答加入history
        self.dst.state['history'].append([self.name, model_response])
        
        self.status_list.append(status)
        
        return model_response

    def is_terminated(self):
        if hasattr(self.policy, 'is_terminated'):
            return self.policy.is_terminated()
        return None

    def get_reward(self):
        if hasattr(self.policy, 'get_reward'):
            return self.policy.get_reward()
        return None

    def init_session(self, **kwargs):
        """Init the attributes of DST and Policy module."""
        if self.nlu is not None:
            self.nlu.init_session()
        if self.dst is not None:
            self.dst.init_session()
            if self.name == 'Doctor':
                self.dst.state['history'].append([self.name, 'null'])
        if self.policy is not None:
            self.policy.init_session(**kwargs)
        if self.nlg is not None:
            self.nlg.init_session()


    def get_in_da(self):
        return self.input_action

    def get_out_da(self):
        return self.output_action
    
    def get_state(self):
        return self.current_state
    
    def get_current_status(self):
        return self.status_list[len(self.status_list)-1]

    
class DiachatAgent2(DiachatAgent):
    '''
        DST(TRADE) + Policy +NLG
    '''
    def __init__(self, dst: DST, policy: Policy, nlg: NLG):
        super(DiachatAgent2, self).__init__(nlu=None,dst=dst,policy=policy,nlg=nlg)
        
        
    def response(self, observation):
        """Generate agent response using the agent modules."""
        #收到用户语句，加入history
        self.dst.state['history'].append([self.opponent_name, observation]) # [['sys', sys_utt], ['user', user_utt],...]
        #更新系统状态，在update函数里会把用户的action写入state['user_action']
        state = self.dst.update(observation)
        state = deepcopy(state) # get rid of reference problem
        self.current_state = state
        #预测出系统的下一步行为，在predict函数里会把系统的action写入state['system_action']
        self.output_action = deepcopy(self.policy.predict(state)) # get rid of reference problem
        #根据预测的行为生成自然语言的回答
        model_response = self.nlg.generate(self.output_action)
        #把系统的回答加入history
        self.dst.state['history'].append([self.name, model_response])
        return model_response
    